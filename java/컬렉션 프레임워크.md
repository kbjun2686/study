# 컬렉션 프레임워크(collections framework)

### 컬렉션(collection)

> 여러 객체(데이터)를 모아 놓은 것을 의미
> 

### 프레임워크(framework)

> 표준화, 정형화된 체계적인 프로그래밍 방식
> 

## 컬렉션 프레임워크

> **컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식**
> 
- 컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 클래스를 제공(저장,삭제,검색,정렬 등)
- java.util패키지에 포함. JDK1.2부터 제공

### 컬렉션 클래스(collection class)

- 다수의 데이터를 저장 할 수 있는 클래스(Vector, ArrayList, HashSet 등)

## 컬렉션 프레임워크의 핵심 인터페이스

### List

- 순서가 있는 데이터의 집합
- 데이터의 중복을 허용한다.(ex. 대기자 명단)
- 구현 클래스 : ArrayList, LinkedList, Stack, Vector 등

### Set

- 순서를 유지하지 않는 데이터의 집합
- 데이터의 중복을 허용하지 않는다.(ex. 양의 정수집합, 소수의 집합 등)
- 구현클래스 : HashSet, TreeSet 등

### Map

- 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합
- 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.(ex. 우편번호, 지역번호(전화번호))
- 구현클래스 : HashMap, TreeMap, Hashtable, Properties 등

## Collection 인터페이스의 메서드

| 메서드 | 설명 |
| --- | --- |
| boolean add(Object o)
boolean addAll(Collection c) | 지정된 객체(o) 또는 Collection(c)의 객체들을 Collection에 추가한다. |
| void clear() | Collection의 모든 객체를 삭제한다. |
| boolean contains(Object o)
boolean containsAll(Collection c) | 지정된 객체(o) 또는 Collection의 객체들이 Collection에 포함되어 있는지 확인한다. |
| boolean equals(Object o) | 동일한 Collection인지 비교한다. |
| int hashCode() | Collection의 hash code를 반환한다. |
| boolean isEmpty() | Collection이 비어있는지 확인한다. |
| Iterator iterator() | Collection의 Iterator를 얻어서 반환한다. |
| boolean remove(Object o) | 지정된 객체를 삭제한다. |
| boolean removeAll(Collection c) | 지정된 Collection에 포함된 객체들을 삭제한다. |
| boolean retainAll(Collection c) | 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection 에서 삭제한다. 
이 작업으로 인해 Collection에 변화가 있으면 true를 그렇지 않으면 false를 반환한다. |
| int size() | Collection에 저장된 객체의 개수를 반환한다. |
| Object[] toArray() | Collection에 저장된 객체를 객체배열(Object[])로 반환한다. |
| Object[] toArray(Object[] a) | 지정된 배열에 Collection의 객체를 저장해서 반환한다. |

### List 인터페이스 - 순서O, 중복O

<img width="622" alt="image" src="https://user-images.githubusercontent.com/108970153/200321291-5122ea3f-d9ee-4013-a93e-cdcbf4afa2f6.png">

- **ArrayList, LinkedList 핵심**

| 메서드 | 설명 |
| --- | --- |
| void add(int index, Object element)
boolean addAll(int index, Collection c) | 지정된 위치(index)에 객체(element) 또는 컬렉션에 포함된 객체들을 추가한다. |
| Object get(int index) | 지정된 위치(index)에 있는 객체를 반환한다. |
| int indexOf(Object o) | 지정된 객체의 위치(index)를 반환한다.
(List의 첫 번째 요소부터 순방향으로 찾는다.) |
| int lastIndexOf(Object o) | 지정된 객체의 위치(index)를 반환한다.
(List의 마지막 요소부터 역방향으로 찾는다.) |
| ListIterator listIterator()
ListIterator listIterator(int index) | List의 객체에 접근할 수 있는 ListIterator를 반환한다. |
| Object remove(int index) | 지정된 위치(index)에 있는 객체를 삭제하고 삭제된 객체를 반환한다. |
| Object set(int index, Object element) | 지정된 위치(index)에 객체(element)를 저장한다. |
| void sort(Comparator c) | 지정된 비교자(comparator)로 List를 정렬한다. |
| List subList(int fromIndex, int toIndex) | 지정된 범위(fromIndex부터 toIndex)에 있는 객체를 반환한다. |

### Set 인터페이스 - 순서X, 중복X

<img width="317" alt="image" src="https://user-images.githubusercontent.com/108970153/200321378-55120caf-7f09-4db3-9cfd-0d56d7b1bf57.png">

- Set인터페이스의 메서드 - Collection 인터페이스와 동일
- 집합과 관련된 메서드(Collection)에 변화가 있으면 true, 아니면 false를 반환
- **HashSet, TreeSet 핵심**

| 메서드 | 설명 |
| --- | --- |
| boolean addAll(Collection c) | 지정된 객체(o) 또는 Collection(c)의 객체들을 Collection에 추가한다.(합집합) |
| boolean containsAll(Collection c) | 지정된 객체(o) 또는 Collection의 객체들이 Collection에 포함되어 있는지 확인한다.(부분집합) |
| boolean removeAll(Collection c) | 지정된 Collection에 포함된 객체들을 삭제한다.(차집합) |
| boolean retainAll(Collection c) | 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection 에서 삭제한다. 
이 작업으로 인해 Collection에 변화가 있으면 true를 그렇지 않으면 false를 반환한다.(교집합) |

### Map 인터페이스 - 순서X, 중복(키X, 값O)

- **HashMap, TreeMap 핵심**
- key와 value 한 쌍을 Entry 라고 한다.

| 메서드 | 설명 |
| --- | --- |
| void clear() | Map의 모든 객체를 삭제한다. |
| boolean containsKey(Object key) | 지정된 key객체와 일치하는 Map의 key객체가 있는지 확인한다. |
| boolean containsValue(Object value) | 지정된 value객체와 일치하는 Map의 value객체가 있는지 확인한다. |
| Set entrySet() | Map에 저장되어 있는 key-value쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환한다. |
| boolean equals(Object o) | 동일한 Map인지 비교한다. |
| Object get(Object key) | 지정한 key객체에 대응하는value객체를 찾아서 반환한다. |
| int hashCode() | 해시코드를 반환한다. |
| boolean isEmpty() | Map이 비어있는지 확인한다. |
| Set keySet() | Map에 저장된 모든 key객체를 반환한다. |
| Object put(Object key, Object value) | Map에 value객체를 key객체에 연결(mapping)하여 저장한다. |
| void putAll(Map t) | 지정된 Map의 모든 key-value쌍을 추가한다. |
| Object remove(Object key) | 지정한 key객체와 일치하는 key-value객체를 삭제한다. |
| int size() | Map에 저장된 key-value쌍의 개수를 반환한다. |
| Collection values() | Map에 저장된 모든 value객체를 반환한다. |

---

## ArrayList

- ArrayList는 기존의 Vector를 개선한 것으로 구현원리와 기능적으로 동일
ArrayList와 달리 Vector는 자체적으로 동기화처리가 되어 있다.
- List 인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용한다.
- 데이터의 저장공간으로 배열을 사용한다.(배열기반)

### ArrayList의 메서드

- 생성자
    - ArrayList() - 기본 생성자
    - ArrayList(Collection c) - 컬렉션을 담아줌. 컬렉션들끼리 변환할 때 주로 사용
    - ArrayList(int initialCapacity) - 배열의 길이
- 메서드
    - boolean add(Object o)
    - void add(int index, Object element)
    - boolean addAll(Collection c)
    - boolean adAll(int index, Collection c)
    - boolean remove(Object o)
    - Object remove(int index)
    - boolean removeAll(Collection c)
    - void clear()
    - int indexOf(Object o)
    - int lastIndexOf(Object o)
    - boolean contains(Object o)
    - Object get(int index)
    - Object set(int index, Object element)
    - List subList(int fromIndex, int toIndex)
    - Object[] toArray()
    - Object[] toArray(Object[] a)
    - boolean isEmpty()
    - void trimToSize()
    - int size()
- ex)
    
    ```java
    // 기본 길이(용량, capacity)가 10인 ArrayList를 생성
    ArrayList list1 = new ArrayList(10);
    // ArrayList에는 객체만 저장 가능
    // autoboxing에 의해 기본형이 참조형으로 자동 변환
    // list1.add(new Integer(5));
    list1.add(5)
    ```
    
    ```java
    list1.remove(1); // index가 1인 객체를 삭제
    list1.remove(new Integer(1)); // 1을 삭제
    ```
    
- **Collection은 인터페이스, Collections는 유틸 클래스!**

### ArrayList에 저장된 객체의 삭제과정

- ArrayList에 저장된 세 번째 데이터(data[2])를 삭제하는 과정. list.remove(2);를 호출

<img width="729" alt="image" src="https://user-images.githubusercontent.com/108970153/200321466-7425106f-2a3b-47df-9949-31828a590633.png">

1. 삭제할 데이터아래의 데이터를 한 칸씩 위로 복사해서 삭제할 데이터를 덮어쓴다.
2. 데이터가 모두 한 칸씩 이동했으므로 마지막 데이터는 null로 변경한다.
3. 데이터가 삭제되어 데이터의 개수가 줄었으므로 size의 값을 감소시킨다.

** 마지막 데이터를 삭제하는 경우, 1 의 과정(배열의 복사)은 필요없다.

- ArrayList에 저장된 첫 번째 객체부터 삭제하는 경우(배열 복사 발생, 마지막 객체 삭제 안됨)
    - for(int i=0; i<list.size(); i++) { list.remove(i) }
    
  <img width="743" alt="image" src="https://user-images.githubusercontent.com/108970153/200321529-d4ebe9f1-5f65-4b41-8070-52610ab9d030.png">
   
- **ArrayList에 저장된 마지막 객체부터 삭제하는 경우(배열 복사 발생안함, 빠름)**
    - for(int i=list.size()-1; i>=0; i--) { list.remove(i); }
    
  <img width="739" alt="image" src="https://user-images.githubusercontent.com/108970153/200321630-42df40b7-bd24-44f3-84f7-8675ddfa50b5.png">


### 배열의 장단점

- 장점 : 배열은 구조가 간단하고 데이터를 읽는 데 걸리는 시간(접근시간)이 짧다.
- 단점 1 : 크기를 변경 할 수 없다.
    - 크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사해야함.
        1. 더 큰 배열을 생성하고
        2. 기존 내용을 새로운 배열에 복사하고
        3. 참조를 변경
    - 크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리가 낭비됨
- 단점 2 : 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
    - 데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 함
    - 그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터삭제)는 빠르다.

## LinkedList - 배열의 단점을 보완

<img width="906" alt="image" src="https://user-images.githubusercontent.com/108970153/200322441-02a4b1b6-7abd-4c78-9733-07151feb09e1.png">

### ArrayList vs LinkedList - 성능 비교

- 순차적으로 데이터를 추가/삭제 - ArrayList가 빠름
- 비순차적으로 데이터를 추가/삭제 - LinkedList가 빠름
- 접근시간(access time) - ArrayList가 빠름

<img width="222" alt="image" src="https://user-images.githubusercontent.com/108970153/200321940-e2c836a1-d987-487b-8056-44f1c072f901.png">

| 컬렉션 | 읽기(접근시간) | 추가/삭제 | 비고 |
| --- | --- | --- | --- |
| ArrayList | 빠르다 | 느리다 | 순차적인 추가삭제는 빠름.
비효율적인 메모리사용 |
| LinkedList | 느리다 | 빠르다 | 데이터가 많을수록 접근성이 떨어짐 |

## 스택과 큐(Stack & Queue)

- 스택(Stack) : LIFO구조. 마지막에 저장된 것을 제일 먼저 꺼내게 된다.
    - 클래스(Stack st = new Stack();)
    - 수식계산, 수식괄호검사, undo/redo, 뒤로/앞으로(웹브라우저)
    - ArrayList 적합
- 큐(Queue) : FIFO구조. 제일 먼저 저장한 것을 제일 먼저 꺼내게 된다.
    - 인터페이스
        - Queue를 구현한 클래스를 사용
        - LinkedList 사용시(Queue g = new LinkdedList();)
        <img width="796" alt="image" src="https://user-images.githubusercontent.com/108970153/200322146-94a1b922-6213-4819-b541-ac48f2412cec.png">
        
    - 최근 사용문서, 인쇄작업대기목록, 버퍼(buffer)
    - LinkedList 적합
    
    <img width="685" alt="image" src="https://user-images.githubusercontent.com/108970153/200322009-711c8be4-b2d0-487c-92a9-b9d600c5fd29.png">
        

### 스택과 큐의 메서드

- Stack의 메서드
    
    
    | 메서드 | 설명 |
    | --- | --- |
    | boolean empty() | Stack이 비어있는지 알려준다. |
    | Object peek() | Stack의 맨 위에 저장된 객체를 반환. pop()과 달리 Stack에서 객체를 꺼내지는 않음.
    (비었을 때는 EmptyStackException발생) |
    | Object pop() | Stack의 맨 위에 저장된 객체를 꺼낸다. (비었을 때는 EmptyStackException발생) |
    | Object push(Object item) | Stack에 객체(item)를 저장한다. |
    | int search(Object o) | Stack에서 주어진 객체(o)를 찾아서 그 위치를 반환.
    못찾으면 -1을 반환(배열과 달리 위치는 0이 아닌 1부터 시작) |
- Queue의 메서드
    
    
    | 메서드 | 설명 |
    | --- | --- |
    | boolean add(Object o) | 지정된 객체를 Queue에 추가한다. 성공하면 true를 반환. 
    저장공간이 부족하면 IllegalStateException 발생 |
    | Object remove() | Queue에서 객체를 꺼내 반환
    비어있으면 NosuchElementException 발생 |
    | Object element() | 삭제없이 요소를 읽어온다. peek와 달리 Queue가 비었을 때 NoSuchElementException발생 |
    | boolean offer(Object o) | Queue에 객체를 저장. 성공하면 true. 실패하면 false를 반환. 예외발생X |
    | Object poll() | Queue에서 객체를 꺼내서 반환. 비어있으면 null을 반환. 예외발생X |
    | Object peek() | 삭제없이 요소를 읽어 온다. Queue가 비어있으면 null을 반환. 예외발생X |
